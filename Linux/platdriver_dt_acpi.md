# Platform driver, device tree, ACPI

組込みLinuxの醍醐味は、ペリフェラルデバイスのカスタマイズ。
悲喜こもごもの、涙なしでは語れない苦労話がある(はず)。

世の中にはたくさんの組込みLinuxデバイスがあります。
それらのデバイスは、まず、SoCベンダーがリファレンスボードを作ります。TIが作っていたりNXPが作っていたりIntelが作っていたりするわけです。
それらの、リファレンスボードを、家電メーカーや車載機器メーカーが自社製品向けにカスタマイズして、独自の組込みLinuxプラットフォームを構築します。

まず、SoCベンダーが違えば、どのようなペリフェラルデバイスが、何個、搭載されているか、や、同種ペリフェラルデバイスでもメーカーや型番が違ってきます。
同じベンダーでも、デバイスの世代や、性能および消費電力のターゲットが異なれば、異なるデバイスが搭載されます。

ここで問題になるのが、それらの異なるデバイスをどのようにLinux kernelで扱うか、です。
例えば、あるボードでは0x10000000番地にUART16550が接続されていますが、別のボードにおいては、UARTは別アドレスに別デバイスが搭載されているでしょう。

また、SoCベンダーは、メーカーがボードをカスタマイズできるように、GPIOやSPIの口を用意しています。
GPIOやSPIはいろいろな入出力に使えるので、メーカーは自社製品の要件に適合するように、いい感じにカスタマイズするわけですね。

ここでGPIOを例にすると、GPIOはLEDはに使われたり、割り込みに使われたり、何らかのデバイスの入出力に使われたりします。
しかし、Linux kernelとしては、GPIOがLEDなのか割り込み線なのか何らかのデバイスの入出力なのか、は知りようがないわけです。

そこで、GPIOは(memory mappedの場合)、ここのアドレスにあって、こういうデバイスだから、このdriverで動かしてね、ということをLinux kernelに伝える仕組みの登場です。

1. platform driver
2. device tree
3. ACPI(のDSDT)

## Platform driver

現在は非推奨の方法です。
やむを得ず使わざるをえない場合もあります。

[omap1 serial](https://github.com/torvalds/linux/blob/master/arch/arm/mach-omap1/serial.c)

## device tree

乱立するplatform driverの惨状に業を煮やしたLinusにより、device treeが開発されることになりました。